# GRPC notes

After using GRPC with golang for several years now, here's a list of things in no particualr order that are important

These are things you are hopefully already doing, but just to call them out explicityly, here's a checklist.

## Server defaults

The defaults are garbage.  It's a bit like the old Apache defaults

I guess the idea might be that the default are so bad you will be forced to change them because performance will be so bad?

It would be great if Google had more warning about this, or just had better defaults, or perhaps an option like "reasonableDefaults".

You really don't want to run with the defaults:
- you likely want to crank up the buffer sizes
- definitely crank up the

Do something like this:

```bash

// ListenAndServeGRPCServer - Start the public GRPC server and add services
func ListenAndServePublicGRPCServer(port string) error {
	lis, err := net.Listen("tcp", ":"+port)
	if err != nil {
		return err
	}

	authInterceptor, err := auth.NewUserTokenUnaryInterceptor(config.GetTokenParserConfig(), []string{}, auth.Strict)
	if err != nil {
		return err
	}

	telemetry := grpchelper.NewMetrics(config.ServiceName + "-grpc-public")

	grpcServer := grpc.NewServer(
		grpc.ReadBufferSize(config.GetGRPCReadBufferSize()),
		grpc.WriteBufferSize(config.GetGRPCWriteBufferSize()),
		grpc.MaxRecvMsgSize(config.GetGRPCMaxRecvMsgSize()),
		grpc.MaxConcurrentStreams(config.GetGRPCMaxConcurrentStreams()),
		grpc.KeepaliveParams(config.GetGRPCKeepAliveConfig()),
		// grpc.NumStreamWorkers(uint32(runtime.GOMAXPROCS(0))), // Future proformance tweak see grpc server.go https://github.com/grpc/grpc-go/blob/v1.45.0/server.go#L449
		grpc.ChainUnaryInterceptor(
			authInterceptor,
			telemetry.GrpcInterceptor,
		),
	)

	// Register Handlers Here, make sure permissions are validated
	partnermgmt.RegisterCPOriginPolicyServiceServer(grpcServer, container.ExternalCPPolicyService)
	partnermgmt.RegisterSPPolicyServiceServer(grpcServer, container.ExternalSPPolicyService)
    // ... Register other services here....

```

See also [config_grpc.go](./config_grpc.go)


## Client side config

Similarly the client side defaults are bad.  There's a lot of built in capabilities that you might assume would be enabled, but they are not.

Key items are:
- Retries! ( and which codes to retry)
- RetrybBack off
- Load balancing ( there's only round robin, which is garbage.  Needs more algorithms.  Another good project for somebody.  No doubt google has better algorithms and they should be in the public library )
- Why aren't the keepalive configs here?  = No idea


The configuration via yaml (?!) is also terrible and very fragile.  In frustration, I ended up writing a litle bit of code just to try to validate the yaml.

Here's some example yamls

See also [../grpc_service_policy_check/grpc_service_policy.yaml](../grpc_service_policy_check/grpc_service_policy.yaml)

Use extreme caution modifying this

I defintely don'd understand why this isn't more standard go config...

On the bight side, you can reuse this yamls with other languages ( like Python if you are that unfortunate... My condulances )

I ended up writing a tiny little tool just for the purposes of making sure the GRPC library was happy with the yamls.

See also [../grpc_service_policy_check/grpc_service_policy_check.go](../grpc_service_policy_check/grpc_service_policy_check.go)

We basically copy this yaml into each container and load it up. #Nasty


## Client side config contiued

With the yaml file avilable, you cna then do something like this:

```bash

	keep := &keepalive.ClientParameters{
		Time:                config.GetGRPCClientKeepAliveTime(),
		PermitWithoutStream: true,
	}

	// see https://github.com/grpc/grpc/blob/master/doc/service_config.md to know more about service config
	// https://github.com/grpc/grpc-go/blob/11feb0a9afd8/examples/features/retry/client/main.go#L36
	// https://grpc.github.io/grpc/core/md_doc_statuscodes.html
	servicePolicyBytes, err := os.ReadFile(config.GPRCServicePolicyConfigFile)
	if err != nil {
		log.Fatal(ctx, "os.ReadFile(GRPCServicePolicyFile):%v", err)
	}

		dialOps = []grpc.DialOption{
			grpc.WithKeepaliveParams(*keep),                              <--- why aren't keepalives part of the policy?
			grpc.WithTransportCredentials(credentials.NewTLS(tlsConfig)),
			grpc.WithReadBufferSize(config.GetGRPCReadBufferSize()),
			grpc.WithWriteBufferSize(config.GetGRPCWriteBufferSize()),
			grpc.WithDefaultServiceConfig(string(servicePolicyBytes)),  <---- SERVICE POLICY
			grpc.WithDefaultCallOptions(grpc.UseCompressor(gzip.Name)),
			grpc.WithUnaryInterceptor(ClientsGrpcMetrics.ClientGrpcInterceptor),
		}
```

## KeepAlives

You defintely want keepalives.  Turn them on.  The above examples turn them on.

Turn them on at both ends, client and server.


## Compression

Compression is not enabled by default. ??!  Maybe there are cases you don't want this.  I don't know what they are.

Protobufs only support gzip.  A great open source project for somebody would be to submit a zstd version.  ( It's probably not hard, and should just be in the standard library )

Also be warned that the gzip support is garbage.  It is NOT negotiated like you might expect based on how HTTP server/clients negioate.  Seems like a missed oppertunity.

You MUST enable it server side before the clint of shizzle breaks.  (Ask me how I know.  Defintely not following the element of least surprise. )

Luckily, it's just a single line to enable it

```bash

package grpcapi

import (
	"net"

	"gitlab.com/sidenio/api.git/pkg/generated/grpc/partnermgmt"
	"gitlab.com/sidenio/go/common.git/pkg/grpchelper"
	"gitlab.com/sidenio/oc-go/accounts-oc.git/pkg/auth"
	"gitlab.com/sidenio/oc-go/partner-mgmt-oc.git/internal/app/config"
	"gitlab.com/sidenio/oc-go/partner-mgmt-oc.git/internal/app/container"

	"google.golang.org/grpc"
	_ "google.golang.org/grpc/encoding/gzip"                         <--------- just add this line
)

// PLEASE NOTE by importing GRPC encoding, this will register the compression.
// _ "google.golang.org/grpc/encoding/gzip"
// https://github.com/grpc/grpc-go/blob/master/encoding/gzip/gzip.go#L42

// Rest of your grpc server instanciation follows

```


## Contexts

This is probably more general golang recommendation, but you MUST handle contexts
and pass them to downstream functions.

This is particularly important for GRPC calls.

I inherited a code base where the inbound ctx was not used, and essentially every function just did good old

```bash
// Don't do this
ctx, cancel :=context.WithCancel(context.Background())
```

It was a disaster.  We had to stop all work for approximiately two (~2) weeks, and go through every line of code
in every micro service to add context handling and timeouts.  It was a lot of work, which payed off, but
it would have been nice to plan this work and not do it the week before a big trial with a customer. #stressful


A common pattern which works ok is something like this to essentailly define shorter timeouts than you need

```bash
func myGRPCHandler(inCtx context.Conext, blah blah...) () {

    const myTimeout = 30 * time.Second
    ctx, cancel := context.WithTimeout(inCtx, myTimeout)

    // Now use ctx

}
```

## MongoDB and protobufs

Don't use Mongo because it garbage!  Don't even wish it on your enemies.  You are better than that.

If you are stuck with it cos somebody made a bad decision, we found that the only way to get this working is to post process the generated code.

( Yes, I nearly died when I first saw this code too :( )

Here's the essense of the code you need to 'sed' the generated code to add the "bson" annotations

```bash

  enterDir ../grpc
  for d in */; do
      enterDir "$d"

      # Add bson annotations to the generated code.
      # See also: https://github.com/golang/protobuf/issues/52
      find ./. -name '*.go' -exec sed -i -e 's/json:"\([^"]*\)"/json:"\1" bson:"\1" redis:"\1"/g' {} \;
      # https://www.everythingcli.org/find-exec-vs-find-xargs/
      leaveDir "$d"
  done
```

## GRPC-Web

Turns out there's a thing called GRPC-Web

gRPC-Web and Istio: A Report from Service Mesh Day
https://blogs.vmware.com/networkvirtualization/2019/04/grpc-web-and-istio.html/

Main docs here:

GitHub - grpc/grpc-web: gRPC for Web Clients
https://github.com/grpc/grpc-web

<fix me> Istio config here

## CORS

Sigh.  This is another ahead where google is saverily lacking with guidance.

We use Flutter with GPRC-web but if you look up how to set the CORS for this you are fresh out of luck.

We use Istio and luckily it handles more of the CORS for you, once you config it.

Here's example config.  The Istio documentation about this is "light" at best.

<fix me> istio config

If you don't have Istio, then I'm not really sure what the "correct" way to handle CORS.

To pass the prefight OPTIONS requests, and assuming you use GPRC-Proxy, then you can add a handler to wrap the rest of your handlers.

( Preflight: https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request )


<fix me> example here
```bash

```

Once you have assed preflight


## GPRC-Proxy

GPRC-Proxy is great.

The problem with GPRC-Proxy is that it's so good you get jokers who just want to use REST.

This means you have to go around and around in circles explaining that there is REST support, but you really don't want to use it unless you are forced too.

